from flask import Flask, request, send_from_directory, jsonify
from pymongo import MongoClient
from tensorflow.keras.models import load_model
import numpy as np
import tensorflow as tf
import cv2
from PIL import Image
from PIL.ExifTags import TAGS
from flask_cors import CORS
import os
import tempfile
from binaryToImage import binary_to_image
from dataExtractFromBinFile import extract_pe_sections, save_section_data
from getMalwareData import find
from imageToBinary import image_to_binary
from isImageFile import is_image_file
from response import compare_prefix_with_prediction

app = Flask(__name__)
CORS(app)

# Load the model
model_new = load_model('C:/Users/harsh/Downloads/Research/malware_classification_model_vgg16_grayscale.h5')

model_new.compile(
    loss='sparse_categorical_crossentropy',
    optimizer='adam',
    metrics=['accuracy']
)

# Function to preprocess and predict a single image
def preprocess_and_predict_new(image_path):
    img = tf.keras.preprocessing.image.load_img(image_path, color_mode='grayscale', target_size=(128, 128))
    img_array = tf.keras.preprocessing.image.img_to_array(img)
    img_array = np.expand_dims(img_array, axis=0)
    img_array /= 255.0

    prediction = model_new.predict(img_array)
    predicted_class = np.argmax(prediction, axis=1)[0]
    return predicted_class

@app.route('/predict', methods=['POST'])
def predict():
    if 'file' not in request.files:
        return jsonify({"error": "No file part"}), 400
    file = request.files['file']
    if file.filename == '':
        return jsonify({"error": "No selected file"}), 400

    # Save the file to a temporary location
    temp_dir = tempfile.gettempdir()
    temp_file_path = os.path.join(temp_dir, file.filename)
    file.save(temp_file_path)

    # Extract basename of the file and create new directory
    base_name = os.path.splitext(file.filename)[0]
    new_dir_path = os.path.join('data', base_name)
    os.makedirs(new_dir_path, exist_ok=True)

    imageFilePath = None
    binaryFilePath = None
    text_path = None
    rdata_path = None
    data_path = None
    rsrc_path = None

    try:
        # Check if the uploaded file is an image
        isImageFile = is_image_file(temp_file_path)
        if isImageFile:
            imageToBinary = image_to_binary(temp_file_path)
            if imageToBinary == (None, None):
                return jsonify({"error": "Unable to process image file"}), 500
            binaryFilePath, imageFilePath = imageToBinary
            # Move the processed files to the new directory
            os.rename(binaryFilePath, os.path.join(new_dir_path, os.path.basename(binaryFilePath)))
            os.rename(imageFilePath, os.path.join(new_dir_path, os.path.basename(imageFilePath)))
            binaryFilePath = os.path.join(new_dir_path, os.path.basename(binaryFilePath))
            imageFilePath = os.path.join(new_dir_path, os.path.basename(imageFilePath))
            prediction1 = preprocess_and_predict_new(imageFilePath)
            sectionData = extract_pe_sections(binaryFilePath)
            saveSectionData = save_section_data(sectionData, new_dir_path)
        else:
            # Move the uploaded .bin file to the new directory
            new_bin_path = os.path.join(new_dir_path, file.filename)
            os.rename(temp_file_path, new_bin_path)
            binaryToImage = binary_to_image(new_bin_path)
            if binaryToImage is None:
                return jsonify({"error": "Unable to process binary file"}), 500
            imageFilePath = binaryToImage
            # Move the processed image file to the new directory
            os.rename(imageFilePath, os.path.join(new_dir_path, os.path.basename(imageFilePath)))
            imageFilePath = os.path.join(new_dir_path, os.path.basename(imageFilePath))
            prediction1 = preprocess_and_predict_new(imageFilePath)
            sectionData = extract_pe_sections(new_bin_path)
            saveSectionData = save_section_data(sectionData, new_dir_path)

        if saveSectionData:
            text_path = next((os.path.join(new_dir_path, f"{path}") for path in saveSectionData if 'text' in path), None)
            rdata_path = next((os.path.join(new_dir_path, f"{path}") for path in saveSectionData if 'rdata' in path), None)
            data_path = next((os.path.join(new_dir_path, f"{path}") for path in saveSectionData if 'data' in path), None)
            rsrc_path = next((os.path.join(new_dir_path, f"{path}") for path in saveSectionData if 'rsrc' in path), None)

        
            prediction = compare_prefix_with_prediction(prediction1)
            print("prediction", prediction)
        
        malwareData = find(prediction)
        print("malwareData", malwareData)

        # Convert absolute paths to relative paths
        relative_image_file_path = os.path.relpath(imageFilePath, start=os.getcwd())
        relative_text_path = os.path.relpath(text_path, start=os.getcwd()) if text_path else None
        relative_rdata_path = os.path.relpath(rdata_path, start=os.getcwd()) if rdata_path else None
        relative_data_path = os.path.relpath(data_path, start=os.getcwd()) if data_path else None
        relative_rsrc_path = os.path.relpath(rsrc_path, start=os.getcwd()) if rsrc_path else None

        response = {
            'prediction': str(prediction),
            'malwareData': malwareData,
            'imageFilePath': relative_image_file_path,
            'text_path': relative_text_path,
            'rdata_path': relative_rdata_path,
            'data_path': relative_data_path,
            'rsrc_path': relative_rsrc_path,
        }
        print("response", response)
        return jsonify(response)
    except Exception as e:
        print(f"Error: {e}")
        return jsonify({"error": str(e)}), 500

@app.route('/data/<path:filename>')
def serve_image(filename):
    return send_from_directory('data', filename)


if __name__ == '__main__':
    app.run(debug=True, port=8000)
